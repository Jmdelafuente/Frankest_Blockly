// const serverURL = "https://incuba.fi.uncoma.edu.ar/franklab/code/:3000";
const serverURL = "http://192.168.122.187:3000";
// WebSocket via Socket.io
var socket = io(serverURL);

async function sendData(data, url = serverURL, verb='POST', callback=false) {
  // console.log("Sending data");

  const XHR = new XMLHttpRequest();

  let urlEncodedData = "",
    urlEncodedDataPairs = [],
    name;

  // Turn the data object into an array of URL-encoded key/value pairs.
  for (name in data) {
    urlEncodedDataPairs.push(
      encodeURIComponent(name) + "=" + encodeURIComponent(data[name])
    );
  }

  // Combine the pairs into a single string and replace all %-encoded spaces to
  // the '+' character; matches the behavior of browser form submissions.
  urlEncodedData = urlEncodedDataPairs.join("&").replace(/%20/g, "+");
  XHR.onreadystatechange = function (e) {
    if (XHR.readyState === 4) {
      if ((XHR.status === 200) || (XHR.status === 204)) {
        // Code here for the server answer when successful
        if (callback !=false){
          callback(XHR.response);
        }
      } else {
        // Code here for the server answer when not successful
        console.log("Ha ocurrido un error en la petición al servidor");
      }
    }
  };
  if(verb == "POST"){

    // Set up our request
    XHR.open(verb, url, true);
    
    // Add the required HTTP header for form data POST requests
    XHR.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' );
    
    // Finally, send our data.
    XHR.send(urlEncodedData);
  }else{
    // Set up our request
    XHR.open(verb, url.concat("?").concat(urlEncodedData), true);

    // Add the required HTTP header for form data POST requests
    XHR.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

    // Finally, send our data.
    XHR.send();
  }
}


/**
 * Save given workspace in as XML for future use
 * 
 */
function saveWorkspace(xml,id, isRemix=false){
  let data = { codigo: xml, token: id};
  let callback = isRemix ? Code.saveRemixURL : Code.saveURL;
  sendData(data, `${serverURL}/guardarXML`,"POST",callback);
}

function loadWorkspace(id){
  let data = { token: id };
  sendData(data, `${serverURL}/cargarXML`, "GET", Code.loadXML);
}

/***
 * Send code to server.
 * Send code via SSE and keep connection alive for highlight block
 */

Code.evaluate = function (code) {
  let id = sessionStorage.getItem("idURL");
  let data = { "codigo": code, "token": id };
    if (typeof EventSource !== "undefined") {
      var evtSource = new EventSource(`${serverURL}/sse`);
      evtSource.onmessage = function(ev){
          var obj = JSON.parse(ev.data);
          if (obj.id != -1){
            console.log(obj.id)
            Code.workspace.highlightBlock(obj.id);
          }else{
            Code.workspace.highlightBlock();
            addConsoleMessage("¡Terminó la ejecución de tu programa!", true);
            Code.stopStream();
            evtSource.close();
          }
      };
    }
  sendData(data, `${serverURL}/procesar`, "POST", Code.startStream);
};

/**
 * Run user's code.
 * Just a quick and dirty eval.  Catch infinite loops.
 */
Code.runJS = function () {
  let originalPrintCode = Blockly.Python['text_prompt_ext']
  let newPrintCode = function (a) { var b = Blockly.Python.provideFunction_("text_prompt", ["def " + Blockly.Python.FUNCTION_NAME_PLACEHOLDER_ + "(msg):", "  try:", "    print('@autogenerated@input@'+str(msg))\n    return raw_input(msg)", "  except NameError:", "    return input(msg)"]), c = a.getField("TEXT") ? Blockly.Python.quote_(a.getFieldValue("TEXT")) : Blockly.Python.valueToCode(a, "TEXT", Blockly.Python.ORDER_NONE) || "''"; b = b + "(" + c + ")"; "NUMBER" == a.getFieldValue("TYPE") && (b = "float(" + b + ")"); return [b, Blockly.Python.ORDER_FUNCTION_CALL] };
  // (Naive) prevent intinite loop
  Blockly.JavaScript.INFINITE_LOOP_TRAP = "checkTimeout();\n";
  // Add event on input request
  Blockly.Python['text_prompt_ext'] = newPrintCode
  // Set block delimiter
  Blockly.Python.STATEMENT_PREFIX = `print("@autogenerated@begin@%1")\n`;
  // Set pause for better UX
  Blockly.Python.STATEMENT_SUFFIX = `time.sleep(0.5)\n`;
  
  var timeouts = 0;
  var checkTimeout = function () {
    if (timeouts++ > 1000000) {
      throw MSG["timeout"];
    }
  };
  var code = "import time\n" + Blockly.Python.workspaceToCode(Code.workspace);
  Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
  try {
    // eval(code);
    Code.evaluate(code);
  } catch (e) {
    alert(MSG["badCode"].replace("%1", e));
  } finally {
    Blockly.Python.STATEMENT_PREFIX = "";
    Blockly.Python.STATEMENT_SUFFIX = "";
    Blockly.Python['text_prompt_ext'] = originalPrintCode;
  }
};

socket.on("mensaje", function (msj) {
  addConsoleMessage(msj);
});

socket.on("input", function (msj) {
  showConsoleInput(msj);
});

socket.on("connection", function (id){
  setValue("idURL", id);
});
