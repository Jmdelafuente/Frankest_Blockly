// WebSocket via Socket.io
var socket = io("localhost:3000");

async function sendData(data, url, verb='POST', callback=false) {
  // console.log("Sending data");

  const XHR = new XMLHttpRequest();

  let urlEncodedData = "",
    urlEncodedDataPairs = [],
    name;

  // Turn the data object into an array of URL-encoded key/value pairs.
  for (name in data) {
    urlEncodedDataPairs.push(
      encodeURIComponent(name) + "=" + encodeURIComponent(data[name])
    );
  }

  // Combine the pairs into a single string and replace all %-encoded spaces to
  // the '+' character; matches the behavior of browser form submissions.
  urlEncodedData = urlEncodedDataPairs.join("&").replace(/%20/g, "+");
  XHR.onreadystatechange = function (e) {
    if (XHR.readyState === 4) {
      if (XHR.status === 200) {
        // Code here for the server answer when successful
        if (callback !=false){
          callback(XHR.response);
        }
      } else {
        // Code here for the server answer when not successful
      }
    }
  };
  if(verb == "POST"){

    // Set up our request
    XHR.open(verb, url, true);
    
    // Add the required HTTP header for form data POST requests
    XHR.setRequestHeader( 'Content-Type', 'application/x-www-form-urlencoded' );
    
    // Finally, send our data.
    XHR.send(urlEncodedData);
  }else{
    // Set up our request
    XHR.open(verb, url.concat("?").concat(urlEncodedData), true);

    // Add the required HTTP header for form data POST requests
    XHR.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");

    // Finally, send our data.
    XHR.send();
  }
}


/**
 * Save given workspace in as XML for future use
 * 
 */
function saveWorkspace(xml,id){
  let data = { codigo: xml, token: id};
  sendData(data, "http://localhost:3000/guardarXML","POST",Code.saveURL);
}

function loadWorkspace(id){
  let data = { token: id };
  // console.log(`id: ${id}`);
  sendData(data, "http://localhost:3000/cargarXML", "GET", Code.loadXML);
}

/***
 * Send code to server.
 * Send code via SSE and keep connection alive for highlight block
 */

Code.evaluate = function (code) {
    let data = {"codigo": code};
      if (typeof EventSource !== "undefined") {
        var evtSource = new EventSource("http://localhost:3000/sse");
        // evtSource.addEventListener(
        //   "highlight",
        //   function (e) {
        //     // console.log("Entre");
        //     var obj = JSON.parse(e.data);
        //     Code.workspace.highlightBlock(obj.id);
        //   },
        //   false
        // );
        evtSource.onmessage = function(ev){
            // console.log(ev);
            var obj = JSON.parse(ev.data);
            if (obj.id != -1){
              Code.workspace.highlightBlock(obj.id);
            }else{
              Code.workspace.highlightBlock();
            }
        };
      }
    sendData(data, "http://localhost:3000/procesar");
};

/**
 * Run user's code.
 * Just a quick and dirty eval.  Catch infinite loops.
 */
Code.runJS = function () {
  // (Naive) prevent intinite loop
  Blockly.JavaScript.INFINITE_LOOP_TRAP = "checkTimeout();\n";
  // Set block delimiter
  Blockly.Python.STATEMENT_PREFIX = `print("@autogenerated@begin@%1")\n`;
  
  var timeouts = 0;
  var checkTimeout = function () {
    if (timeouts++ > 1000000) {
      throw MSG["timeout"];
    }
  };
  var code = Blockly.Python.workspaceToCode(Code.workspace);
  Blockly.JavaScript.INFINITE_LOOP_TRAP = null;
  try {
    // eval(code);
    Code.evaluate(code);
  } catch (e) {
    alert(MSG["badCode"].replace("%1", e));
  } finally {
    Blockly.Python.STATEMENT_PREFIX = "";
  }
};

socket.on("mensaje", function (msj) {
  addConsoleMessage(msj);
});